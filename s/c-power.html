<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="author" content="dot1q@Anonymous"><meta name="renderer" content="webkit"><meta name="copyright" content="dot1q@Anonymous"><meta name="keywords" content="hexo,hexo-theme,hexo-blog"><meta name="description" content=""><meta name="description" content="本文主要针对C&#x2F;C++常用函数库进行梳理 文章导航   类型 include 路径 基本信息    Win标准 &lt;stdio.h&gt; stdio.h标准库 提供了处理文件和标准输入&#x2F;输出流的各种函数和类型   Win标准 &lt;stdlib.h&gt; stdlib.h标准库 提供了许多通用工具函数，包括内存分配、进程控制、排序和搜索、以及字符串转换等   Win"><meta property="og:type" content="article"><meta property="og:title" content="C语言中的函数库与对应作用"><meta property="og:url" content="https://cyber-mobile.net/s/c-power.html"><meta property="og:site_name" content="DUK技术栈-v3.8.297"><meta property="og:description" content="本文主要针对C&#x2F;C++常用函数库进行梳理 文章导航   类型 include 路径 基本信息    Win标准 &lt;stdio.h&gt; stdio.h标准库 提供了处理文件和标准输入&#x2F;输出流的各种函数和类型   Win标准 &lt;stdlib.h&gt; stdlib.h标准库 提供了许多通用工具函数，包括内存分配、进程控制、排序和搜索、以及字符串转换等   Win"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-03-27T01:56:00.000Z"><meta property="article:modified_time" content="2025-04-21T03:48:48.000Z"><meta property="article:author" content="dot1q@Anonymous"><meta name="twitter:card" content="summary"><meta http-equiv="Cache-control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><link rel="icon" href="/assets/favicon.ico"><title>C语言中的函数库与对应作用 · DUK技术栈-v3.8.297</title><script>!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout((function(){t.rel="stylesheet",t.media="only x"})),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",(function(){e.poly(),t.clearInterval(a)})):t.attachEvent&&t.attachEvent("onload",(function(){e.poly(),t.clearInterval(a)}))}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this)</script><style type="text/css">@font-face{font-family:Oswald-Regular;src:url(/font/Oswald-Regular.ttf)}body{margin:0}.back-top,.container,.sidebar,.site-intro-meta,.toc-wrapper,footer,header{display:none}.site-intro{position:relative;z-index:3;width:100%;overflow:hidden}.site-intro-placeholder{position:absolute;z-index:-2;top:0;left:0;width:calc(100% + 300px);height:100%;background:repeating-linear-gradient(-45deg,#444 0,#444 80px,#333 80px,#333 160px);background-position:center center;transform:translate3d(-226px,0,0);animation:gradient-move 2.5s ease-out 0s infinite}@keyframes gradient-move{0%{transform:translate3d(-226px,0,0)}100%{transform:translate3d(0,0,0)}}</style><link rel="preload" href="/css/style.css?v=20211217" as="style" onload='this.onload=null,this.rel="stylesheet"'><link rel="preload" href="/css/dark.css?v=20211217" as="style"><link rel="stylesheet" href="/css/dark.css"><link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width:960px)"><link rel="preload" href="/static/jquery.fancybox.min.css" as="style" onload='this.onload=null,this.rel="stylesheet"'><link rel="preload" href="/static/jquery.min.js" as="script"><link rel="preload" href="/scripts/main.js?v=20211217" as="script"><link rel="preload" href="/scripts/dark.js?v=20211217" as="script"><link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin><link rel="preload" href="/static/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin><meta name="generator" content="Hexo 7.2.0"></head><script src="/static/jquery.min.js"></script><script type="text/javascript">null==typeof window.$&&(console.warn("jquery load from jsdelivr failed, will load local script"),document.write('<script src="/lib/jquery.min.js" />'))</script><body class="post-body"><header class="header header-mobile"><div class="header-element"><div class="read-progress"></div></div><div class="header-element"><div class="header-sidebar-menu"><div style="padding-left:1px">&#xe775;</div></div></div><div class="header-actions"><span class="header-theme-btn header-element"><i class="fas fa-adjust"></i> </span><span class="home-link header-element"><a href="/">DUK技术栈-v3.8.297</a></span></div><div class="banner"><div class="blog-title header-element"><a href="/">DUK技术栈-v3.8.297</a></div><div class="post-title header-element"><a href="#" class="post-name">C语言中的函数库与对应作用</a></div></div></header><footer class="footer-fixed"><div class="footer-fixed-element"><div class="back-top back-top-hidden"><div>&#xe639;</div></div></div></footer><div class="wrapper"><div class="site-intro" style="height:50vh"><div class="site-intro-placeholder"></div><div class="site-intro-img" style="background-image:url(/intro/post-bg.jpg)"></div><div class="site-intro-meta"><h1 class="intro-title">C语言中的函数库与对应作用</h1><p class="intro-subtitle"></p><div class="post-intros"><div class="post-intro-tags"></div><div class="post-intro-meta"><span class="iconfont-archer post-intro-calander">&#xe676;</span> <span class="post-intro-time">2025/03/27</span><span id="busuanzi_container_page_pv" class="busuanzi-pv"><span class="iconfont-archer post-intro-busuanzi">&#xe602;</span> <span id="busuanzi_value_page_pv"></span> </span><span class="share-wrapper"><span class="iconfont-archer share-icon">&#xe71d;</span> <span class="share-text">Share</span><ul class="share-list"><li class="iconfont-archer share-qr" data-type="qr">&#xe75b;<div class="share-qrcode"></div></li><li class="iconfont-archer" data-type="weibo">&#xe619;</li><li class="iconfont-archer" data-type="qzone">&#xe62e;</li><li class="iconfont-archer" data-type="twitter">&#xe634;</li><li class="iconfont-archer" data-type="facebook">&#xe67a;</li></ul></span></div></div></div></div><script>function getBrowserVersions(){var e=window.navigator.userAgent;return{userAgent:e,trident:e.indexOf("Trident")>-1,presto:e.indexOf("Presto")>-1,webKit:e.indexOf("AppleWebKit")>-1,gecko:e.indexOf("Gecko")>-1&&-1==e.indexOf("KHTML"),mobile:!!e.match(/AppleWebKit.*Mobile.*/),ios:!!e.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:e.indexOf("Android")>-1||e.indexOf("Linux")>-1,iPhone:e.indexOf("iPhone")>-1||e.indexOf("Mac")>-1,iPad:e.indexOf("iPad")>-1,webApp:-1==e.indexOf("Safari"),weixin:-1==e.indexOf("MicroMessenger"),uc:e.indexOf("UCBrowser")>-1}}var browser={versions:getBrowserVersions()};function fontLoaded(){if(console.log("font loaded"),document.getElementsByClassName("site-intro-meta")){document.getElementsByClassName("intro-title")[0].classList.add("intro-fade-in"),document.getElementsByClassName("intro-subtitle")[0].classList.add("intro-fade-in");var e=document.getElementsByClassName("post-intros")[0];e&&e.classList.add("post-fade-in")}}function asyncCb(){browser.versions.uc?(console.log("UCBrowser"),fontLoaded()):WebFont.load({custom:{families:["Oswald-Regular"]},loading:function(){},active:function(){fontLoaded()},inactive:function(){console.log("inactive: timeout"),fontLoaded()},timeout:5e3})}function asyncErr(){console.warn("script load from CDN failed, will load local script")}function async(e,n,o){var t=document,i="script",s=t.createElement(i),a=t.getElementsByTagName(i)[0];s.src=e,n&&s.addEventListener("load",(function(e){n(null,e)}),!1),o&&s.addEventListener("error",(function(e){o(null,e)}),!1),a.parentNode.insertBefore(s,a)}console.log("userAgent: "+browser.versions.userAgent);var asyncLoadWithFallBack=function(e,n,o){var t=function(){o(),e.shift(),e.length&&async(e[0],n,t)};async(e[0],n,t)};asyncLoadWithFallBack(["/static/webfontloader.js","/lib/webfontloader.min.js"],asyncCb,asyncErr)</script><img class="loading" src="/assets/loading.svg" style="display:block;margin:6rem auto 0 auto;width:6rem;height:6rem"><div class="container container-unloaded"><main class="main post-page"><article class="article-entry"><blockquote><h2 id="本文主要针对C-C-常用函数库进行梳理"><a href="#本文主要针对C-C-常用函数库进行梳理" class="headerlink" title="本文主要针对C&#x2F;C++常用函数库进行梳理"></a>本文主要针对C&#x2F;C++常用函数库进行梳理</h2></blockquote><h3 id="文章导航"><a href="#文章导航" class="headerlink" title="文章导航"></a>文章导航</h3><table><thead><tr><th align="center">类型</th><th align="center">include</th><th align="center">路径</th><th align="left">基本信息</th></tr></thead><tbody><tr><td align="center">Win标准</td><td align="center">&lt;stdio.h&gt;</td><td align="center"><a href="#stdio%E6%A0%87%E5%87%86%E5%BA%93">stdio.h标准库</a></td><td align="left">提供了处理文件和标准输入&#x2F;输出流的各种函数和类型</td></tr><tr><td align="center">Win标准</td><td align="center">&lt;stdlib.h&gt;</td><td align="center"><a href="#stdlib%E6%A0%87%E5%87%86%E5%BA%93">stdlib.h标准库</a></td><td align="left">提供了许多通用工具函数，包括内存分配、进程控制、排序和搜索、以及字符串转换等</td></tr><tr><td align="center">Win标准</td><td align="center">&lt;string.h&gt;</td><td align="center"><a href="#string%E6%A0%87%E5%87%86%E5%BA%93">string.h标准库</a></td><td align="left">提供了一组用于处理字符串和内存块的函数。这些函数涵盖了字符串复制、连接、比较、搜索和内存操作等</td></tr><tr><td align="center">Unix标准</td><td align="center">&lt;unistd.h&gt;</td><td align="center"><a href="#unistd%E6%A0%87%E5%87%86%E5%BA%93">unistd.h标准库</a></td><td align="left">提供对 POSIX 操作系统 API 的访问功能的头文件的名称</td></tr></tbody></table><hr><h3 id="函数库详情"><a href="#函数库详情" class="headerlink" title="函数库详情"></a>函数库详情</h3><ul><li><h4 id="stdio标准库"><a href="#stdio标准库" class="headerlink" title="stdio标准库"></a>stdio标准库</h4></li></ul><h5 id="stdio-h变量"><a href="#stdio-h变量" class="headerlink" title="stdio.h变量"></a>stdio.h变量</h5><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">size_t</td><td align="left">无符号整数类型，它是 sizeof 关键字的结果，表示对象大小</td></tr><tr><td align="left">FILE</td><td align="left">文件流类型，适合存储文件流信息的对象类型</td></tr><tr><td align="left">fpos_t</td><td align="left">文件位置类型，适合存储文件中任何位置的对象类型</td></tr></tbody></table><h5 id="stdio-h宏"><a href="#stdio-h宏" class="headerlink" title="stdio.h宏"></a>stdio.h宏</h5><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">NULL</td><td align="left">一个空指针常量的值</td></tr><tr><td align="left">EOF</td><td align="left">一个表示已经到达文件结束的负整数</td></tr><tr><td align="left">BUFSIZ</td><td align="left">一个整数，该整数代表了 setbuf 函数使用的缓冲区大小</td></tr><tr><td align="left">FOPEN_MAX</td><td align="left">一个整数，该整数代表了系统可以同时打开的文件数量</td></tr><tr><td align="left">FILENAME_MAX</td><td align="left">一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值</td></tr><tr><td align="left">L_tmpnam</td><td align="left">一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度</td></tr><tr><td align="left">TMP_MAX</td><td align="left">这个宏是 tmpnam 函数可生成的独特文件名的最大数量</td></tr><tr><td align="left">stderr、stdin 和 stdout</td><td align="left">这些宏是指向 FILE 类型的指针，分别对应于标准错误、标准输入和标准输出流</td></tr><tr><td align="left">SEEK_CUR、SEEK_END 和 SEEK_SET</td><td align="left">这些宏是在 fseek 函数中使用，用于在一个文件中定位不同的位置</td></tr><tr><td align="left">_IOFBF、_IOLBF 和 _IONBF</td><td align="left">这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数</td></tr></tbody></table><h5 id="stdio-h函数"><a href="#stdio-h函数" class="headerlink" title="stdio.h函数"></a>stdio.h函数</h5><table><thead><tr><th align="left">函数</th><th align="left">实践</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">int fclose()</td><td align="left">FILE *stream</td><td align="left">关闭流 stream。刷新所有的缓冲区</td></tr><tr><td align="left">void clearerr()</td><td align="left">FILE *stream</td><td align="left">清除给定流 stream 的文件结束和错误标识符</td></tr><tr><td align="left">int feof()</td><td align="left">FILE *stream</td><td align="left">测试给定流 stream 的文件结束标识符</td></tr><tr><td align="left">int ferror()</td><td align="left">FILE *stream</td><td align="left">测试给定流 stream 的错误标识符</td></tr><tr><td align="left">int fflush()</td><td align="left">FILE *stream</td><td align="left">刷新流 stream 的输出缓冲区</td></tr><tr><td align="left">int fgetpos()</td><td align="left">FILE *stream, fpos_t *pos</td><td align="left">获取流 stream 的当前文件位置，并把它写入到 pos</td></tr><tr><td align="left">FILE *fopen()</td><td align="left">const char *filename, const char *mode</td><td align="left">使用给定的模式 mode 打开 filename 所指向的文件</td></tr><tr><td align="left">size_t fread()</td><td align="left">void *ptr, size_t size, size_t nmemb, FILE *stream</td><td align="left">从给定流 stream 读取数据到 ptr 所指向的数组中</td></tr><tr><td align="left">FILE *freopen()</td><td align="left">const char *filename, const char *mode, FILE *stream</td><td align="left">把一个新的文件名 filename 与给定的打开的流 stream 关联，同时关闭流中的旧文件</td></tr><tr><td align="left">int fseek()</td><td align="left">FILE *stream, long int offset, int whence</td><td align="left">设置流 stream 的文件位置为给定的偏移 offset，参数 offset 意味着从给定的 whence 位置查找的字节数</td></tr><tr><td align="left">int fsetpos()</td><td align="left">FILE *stream, const fpos_t *pos</td><td align="left">设置给定流 stream 的文件位置为给定的位置。参数 pos 是由函数 fgetpos 给定的位置</td></tr><tr><td align="left">long int ftell()</td><td align="left">FILE *stream</td><td align="left">返回给定流 stream 的当前文件位置</td></tr><tr><td align="left">size_t fwrite()</td><td align="left">const void *ptr, size_t size, size_t nmemb, FILE *stream</td><td align="left">把 ptr 所指向的数组中的数据写入到给定流 stream 中</td></tr><tr><td align="left">int remove()</td><td align="left">const char *filename</td><td align="left">删除给定的文件名 filename，以便它不再被访问</td></tr><tr><td align="left">int rename()</td><td align="left">const char *old_filename, const char *new_filename</td><td align="left">把 old_filename 所指向的文件名改为 new_filename</td></tr><tr><td align="left">void rewind()</td><td align="left">FILE *stream</td><td align="left">设置文件位置为给定流 stream 的文件的开头</td></tr><tr><td align="left">void setbuf()</td><td align="left">FILE *stream, char *buffer</td><td align="left">定义流 stream 应如何缓冲</td></tr><tr><td align="left">FILE *tmpfile()</td><td align="left">void</td><td align="left">以二进制更新模式(wb+)创建临时文件</td></tr><tr><td align="left">char *tmpnam()</td><td align="left">char *str</td><td align="left">生成并返回一个有效的临时文件名，该文件名之前是不存在的</td></tr><tr><td align="left">int fprintf()</td><td align="left">FILE *stream, const char *format, …</td><td align="left">发送格式化输出到流 stream 中</td></tr><tr><td align="left">int printf()</td><td align="left">const char *format, …</td><td align="left">发送格式化输出到标准输出 stdout</td></tr><tr><td align="left">int sprintf()</td><td align="left">char *str, const char *format, …</td><td align="left">发送格式化输出到字符串</td></tr><tr><td align="left">int vfprintf()</td><td align="left">FILE *stream, const char *format, va_list arg</td><td align="left">使用参数列表发送格式化输出到流 stream 中</td></tr><tr><td align="left">int vprintf()</td><td align="left">const char *format, va_list arg</td><td align="left">使用参数列表发送格式化输出到标准输出 stdout</td></tr><tr><td align="left">int vsprintf()</td><td align="left">char *str, const char *format, va_list arg</td><td align="left">使用参数列表发送格式化输出到字符串</td></tr><tr><td align="left">int fscanf()</td><td align="left">FILE *stream, const char *format, …</td><td align="left">从流 stream 读取格式化输入</td></tr><tr><td align="left">int scanf()</td><td align="left">const char *format, …</td><td align="left">从标准输入 stdin 读取格式化输入</td></tr><tr><td align="left">int sscanf()</td><td align="left">const char *str, const char *format, …</td><td align="left">从字符串读取格式化输入</td></tr><tr><td align="left">int fgetc()</td><td align="left">FILE *stream</td><td align="left">从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动</td></tr><tr><td align="left">char *fgets()</td><td align="left">char *str, int n, FILE *stream</td><td align="left">从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</td></tr><tr><td align="left">int fputc()</td><td align="left">int char, FILE *stream</td><td align="left">把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动</td></tr><tr><td align="left">int fputs()</td><td align="left">const char *str, FILE *stream</td><td align="left">把字符串写入到指定的流 stream 中，但不包括空字符</td></tr><tr><td align="left">int getc()</td><td align="left">FILE *stream</td><td align="left">从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动</td></tr><tr><td align="left">int getchar()</td><td align="left">void</td><td align="left">从标准输入 stdin 获取一个字符（一个无符号字符）</td></tr><tr><td align="left">char *gets()</td><td align="left">char *str</td><td align="left">从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</td></tr><tr><td align="left">int putc()</td><td align="left">int char, FILE *stream</td><td align="left">把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动</td></tr><tr><td align="left">int putchar()</td><td align="left">int char</td><td align="left">把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中</td></tr><tr><td align="left">int puts()</td><td align="left">const char *str</td><td align="left">把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中</td></tr><tr><td align="left">int ungetc()</td><td align="left">int char, FILE *stream</td><td align="left">把字符 char（一个无符号字符）推入到指定的流 stream 中，以便它是下一个被读取到的字符</td></tr><tr><td align="left">void perror()</td><td align="left">const char *str</td><td align="left">把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格</td></tr><tr><td align="left">int snprintf()</td><td align="left">char *str, size_t size, const char *format, …</td><td align="left">格式字符串到 str 中</td></tr></tbody></table><hr><ul><li><h4 id="stdlib标准库"><a href="#stdlib标准库" class="headerlink" title="stdlib标准库"></a>stdlib标准库</h4></li></ul><h5 id="stdlib-h变量"><a href="#stdlib-h变量" class="headerlink" title="stdlib.h变量"></a>stdlib.h变量</h5><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">size_t</td><td align="left">这是无符号整数类型，它是 sizeof 关键字的结果</td></tr><tr><td align="left">wchar_t</td><td align="left">这是一个宽字符常量大小的整数类型</td></tr><tr><td align="left">div_t</td><td align="left">这是 div 函数返回的结构</td></tr><tr><td align="left">ldiv_t</td><td align="left">这是 ldiv 函数返回的结构</td></tr></tbody></table><h5 id="stdlib-h宏"><a href="#stdlib-h宏" class="headerlink" title="stdlib.h宏"></a>stdlib.h宏</h5><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">NULL</td><td align="left">这个宏是一个空指针常量的值</td></tr><tr><td align="left">EXIT_FAILURE</td><td align="left">这是 exit 函数失败时要返回的值</td></tr><tr><td align="left">EXIT_SUCCESS</td><td align="left">这是 exit 函数成功时要返回的值</td></tr><tr><td align="left">RAND_MAX</td><td align="left">这个宏是 rand 函数返回的最大值</td></tr><tr><td align="left">MB_CUR_MAX</td><td align="left">这个宏表示在多字节字符集中的最大字符数，不能大于 MB_LEN_MAX</td></tr></tbody></table><h5 id="stdlib-h函数"><a href="#stdlib-h函数" class="headerlink" title="stdlib.h函数"></a>stdlib.h函数</h5><table><thead><tr><th align="left">函数</th><th align="left">实践</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">double atof()</td><td align="left">const char *str</td><td align="left">把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）</td></tr><tr><td align="left">int atoi()</td><td align="left">const char *str</td><td align="left">把参数 str 所指向的字符串转换为一个整数（类型为 int 型）</td></tr><tr><td align="left">long int atol()</td><td align="left">const char *str</td><td align="left">把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）</td></tr><tr><td align="left">double strtod()</td><td align="left">const char *str, char **endptr</td><td align="left">把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）</td></tr><tr><td align="left">long int strtol()</td><td align="left">const char *str, char **endptr, int base</td><td align="left">把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）</td></tr><tr><td align="left">unsigned long int strtoul()</td><td align="left">const char *str, char **endptr, int base</td><td align="left">把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）</td></tr><tr><td align="left">void *calloc()</td><td align="left">size_t nitems, size_t size</td><td align="left">分配所需的内存空间，并返回一个指向它的指针</td></tr><tr><td align="left">void free()</td><td align="left">void *ptr</td><td align="left">释放之前调用 calloc、malloc 或 realloc 所分配的内存空间</td></tr><tr><td align="left">void *malloc()</td><td align="left">size_t size</td><td align="left">分配所需的内存空间，并返回一个指向它的指针</td></tr><tr><td align="left">void *realloc()</td><td align="left">void *ptr, size_t size</td><td align="left">尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小</td></tr><tr><td align="left">void abort()</td><td align="left">void</td><td align="left">使一个异常程序终止</td></tr><tr><td align="left">int atexit()</td><td align="left">void (*func)(void)</td><td align="left">当程序正常终止时，调用指定的函数 func</td></tr><tr><td align="left">void exit()</td><td align="left">int status</td><td align="left">使程序正常终止</td></tr><tr><td align="left">char *getenv()</td><td align="left">const char *name</td><td align="left">搜索 name 所指向的环境字符串，并返回相关的值给字符串</td></tr><tr><td align="left">int system()</td><td align="left">const char *string</td><td align="left">由 string 指定的命令传给要被命令处理器执行的主机环境</td></tr><tr><td align="left">void *bsearch()</td><td align="left">const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *)</td><td align="left">执行二分查找</td></tr><tr><td align="left">void qsort()</td><td align="left">void *base, size_t nitems, size_t size, int (*compar)(const void <em>, const void</em>)</td><td align="left">数组排序</td></tr><tr><td align="left">int abs()</td><td align="left">int x</td><td align="left">返回 x 的绝对值</td></tr><tr><td align="left">div_t div()</td><td align="left">int numer, int denom</td><td align="left">分子除以分母</td></tr><tr><td align="left">long int labs()</td><td align="left">long int x</td><td align="left">返回 x 的绝对值</td></tr><tr><td align="left">ldiv_t ldiv()</td><td align="left">long int numer, long int denom</td><td align="left">分子除以分母</td></tr><tr><td align="left">int rand()</td><td align="left">void</td><td align="left">返回一个范围在 0 到 RAND_MAX 之间的伪随机数</td></tr><tr><td align="left">void srand()</td><td align="left">unsigned int seed</td><td align="left">该函数播种由函数 rand 使用的随机数发生器</td></tr><tr><td align="left">int mblen()</td><td align="left">const char *str, size_t n</td><td align="left">返回参数 str 所指向的多字节字符的长度</td></tr><tr><td align="left">size_t mbstowcs()</td><td align="left">schar_t *pwcs, const char *str, size_t n</td><td align="left">把参数 str 所指向的多字节字符的字符串转换为参数 pwcs 所指向的数组</td></tr><tr><td align="left">int mbtowc()</td><td align="left">wchar_t *pwc, const char *str, size_t n</td><td align="left">检查参数 str 所指向的多字节字符</td></tr><tr><td align="left">size_t wcstombs()</td><td align="left">char *str, const wchar_t *pwcs, size_t n</td><td align="left">把数组 pwcs 中存储的编码转换为多字节字符，并把它们存储在字符串 str 中</td></tr><tr><td align="left">int wctomb()</td><td align="left">char *str, wchar_t wchar</td><td align="left">检查对应于参数 wchar 所给出的多字节字符的编码</td></tr></tbody></table><hr><ul><li><h4 id="string标准库"><a href="#string标准库" class="headerlink" title="string标准库"></a>string标准库</h4></li></ul><h5 id="string-h变量"><a href="#string-h变量" class="headerlink" title="string.h变量"></a>string.h变量</h5><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">size_t</td><td align="left">这是无符号整数类型，它是 sizeof 关键字的结果</td></tr></tbody></table><h5 id="string-h宏"><a href="#string-h宏" class="headerlink" title="string.h宏"></a>string.h宏</h5><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">NULL</td><td align="left">这个宏是一个空指针常量的值</td></tr></tbody></table><h5 id="string-h函数"><a href="#string-h函数" class="headerlink" title="string.h函数"></a>string.h函数</h5><table><thead><tr><th align="left">函数</th><th align="left">实践</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">void *memchr()</td><td align="left">const void *str, int c, size_t n</td><td align="left">在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置</td></tr><tr><td align="left">int memcmp()</td><td align="left">const void *str1, const void *str2, size_t n</td><td align="left">把 str1 和 str2 的前 n 个字节进行比较</td></tr><tr><td align="left">void *memcpy()</td><td align="left">void *dest, const void *src, size_t n</td><td align="left">从 src 复制 n 个字符到 dest</td></tr><tr><td align="left">void *memmove()</td><td align="left">void *dest, const void *src, size_t n</td><td align="left">另一个用于从 src 复制 n 个字符到 dest 的函数</td></tr><tr><td align="left">void *memset()</td><td align="left">void *str, int c, size_t n</td><td align="left">将指定的值 c 复制到 str 所指向的内存区域的前 n 个字节中</td></tr><tr><td align="left">char *strcat()</td><td align="left">char *dest, const char *src</td><td align="left">把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</td></tr><tr><td align="left">char *strncat()</td><td align="left">char *dest, const char *src, size_t n</td><td align="left">把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止</td></tr><tr><td align="left">char *strchr()</td><td align="left">const char *str, int c</td><td align="left">在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置</td></tr><tr><td align="left">int strcmp()</td><td align="left">const char *str1, const char *str2</td><td align="left">把 str1 所指向的字符串和 str2 所指向的字符串进行比较</td></tr><tr><td align="left">int strncmp()</td><td align="left">const char *str1, const char *str2, size_t n</td><td align="left">把 str1 和 str2 进行比较，最多比较前 n 个字节</td></tr><tr><td align="left">int strcoll()</td><td align="left">const char *str1, const char *str2</td><td align="left">把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置</td></tr><tr><td align="left">char *strcpy()</td><td align="left">char *dest, const char *src</td><td align="left">把 src 所指向的字符串复制到 dest</td></tr><tr><td align="left">char *strncpy()</td><td align="left">char *dest, const char *src, size_t n</td><td align="left">把 src 所指向的字符串复制到 dest，最多复制 n 个字符</td></tr><tr><td align="left">size_t strcspn()</td><td align="left">const char *str1, const char *str2</td><td align="left">检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符</td></tr><tr><td align="left">char *strerror()</td><td align="left">int errnum</td><td align="left">从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针</td></tr><tr><td align="left">size_t strlen()</td><td align="left">const char *str</td><td align="left">计算字符串 str 的长度，直到空结束字符，但不包括空结束字符</td></tr><tr><td align="left">char *strpbrk()</td><td align="left">const char *str1, const char *str2</td><td align="left">检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置</td></tr><tr><td align="left">char *strrchr()</td><td align="left">const char *str, int c</td><td align="left">在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置</td></tr><tr><td align="left">size_t strspn()</td><td align="left">const char *str1, const char *str2</td><td align="left">检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标</td></tr><tr><td align="left">char *strstr()</td><td align="left">const char *haystack, const char *needle</td><td align="left">在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置</td></tr><tr><td align="left">char *strtok()</td><td align="left">char *str, const char *delim</td><td align="left">分解字符串 str 为一组字符串，delim 为分隔符</td></tr><tr><td align="left">size_t strxfrm()</td><td align="left">char *dest, const char *src, size_t n</td><td align="left">根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中</td></tr></tbody></table><hr><ul><li><h4 id="unistd标准库"><a href="#unistd标准库" class="headerlink" title="unistd标准库"></a>unistd标准库</h4></li></ul><h5 id="unistd-h变量"><a href="#unistd-h变量" class="headerlink" title="unistd.h变量"></a>unistd.h变量</h5><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead></table><h5 id="unistd-h宏"><a href="#unistd-h宏" class="headerlink" title="unistd.h宏"></a>unistd.h宏</h5><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead></table><h5 id="unistd-h函数"><a href="#unistd-h函数" class="headerlink" title="unistd.h函数"></a>unistd.h函数</h5><table><thead><tr><th align="left">函数</th><th align="left">实践</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">close()</td><td align="left">int fd</td><td align="left">当文件操作完成后，需要关闭文件以释放系统资源，避免资源泄漏</td></tr><tr><td align="left">read()</td><td align="left">int fd, void *buf, size_t count</td><td align="left">从文件、管道或其他文件描述符读取数据，例如读取文件内容或从网络套接字接收数据</td></tr><tr><td align="left">write()</td><td align="left">int fd, const void *buf, size_t count</td><td align="left">将数据写入文件、管道或网络套接字，如写入文件内容或发送网络数据</td></tr><tr><td align="left">fork()</td><td align="left">-</td><td align="left">当需要并发执行任务，例如创建一个新的进程来处理其他任务，如并行计算、服务处理等</td></tr><tr><td align="left">execve()</td><td align="left">const char *pathname, char *const argv[], char *const envp[]</td><td align="left">用于启动新的程序，例如在子进程中运行不同的可执行文件</td></tr><tr><td align="left">wait()</td><td align="left">int *status</td><td align="left">父进程需要等待子进程完成任务并获取其结果或状态，保证进程的顺序执行</td></tr><tr><td align="left">pipe()</td><td align="left">int pipefd[2]</td><td align="left">在父子进程或不同进程间传递数据，如父进程向子进程发送数据或反之</td></tr><tr><td align="left">shmget()</td><td align="left">key_t key, size_t size, int shmflg</td><td align="left">在进程间共享大量数据，例如多个进程需要访问同一块内存区域</td></tr><tr><td align="left">getpid()</td><td align="left">-</td><td align="left">用于标识进程，如日志记录、进程间通信时区分不同进程</td></tr><tr><td align="left">getppid()</td><td align="left">-</td><td align="left">当需要知道父进程的信息，如子进程向父进程发送信息时</td></tr><tr><td align="left">sleep()</td><td align="left">unsigned int seconds</td><td align="left">当需要暂停进程一段时间，如定时任务的等待时间、避免 CPU 占用等</td></tr><tr><td align="left">chdir()</td><td align="left">const char *path</td><td align="left">在文件操作中切换工作目录，方便相对路径的文件操作</td></tr></tbody></table><hr><h3 id="以上便是本章节全部内容"><a href="#以上便是本章节全部内容" class="headerlink" title="以上便是本章节全部内容"></a>以上便是本章节全部内容</h3><h4 id="感谢阅读"><a href="#感谢阅读" class="headerlink" title="感谢阅读"></a>感谢阅读</h4></article><div class="license-wrapper"><p>原文作者：<a href="https://cyber-mobile.net">dot1q@Anonymous</a></p><p>原文链接：<a href="https://cyber-mobile.net/s/c-power.html">https://cyber-mobile.net/s/c-power.html</a></p><p>发表日期：<a href="https://cyber-mobile.net/s/c-power.html">March 27th 2025, 1:56:00 am</a></p><p>更新日期：<a href="https://cyber-mobile.net/s/c-power.html">April 21st 2025, 3:48:48 am</a></p><p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><ul class="post-paginator"><li class="next"><div class="nextSlogan">Next Post</div><a href="/s/redis.html" title="云原生部署redis服务"><div class="nextTitle">云原生部署redis服务</div></a></li><li class="previous"><div class="prevSlogan">Previous Post</div><a href="/s/version.html" title="Linux查看内核及系统版本相关技巧"><div class="prevTitle">Linux查看内核及系统版本相关技巧</div></a></li></ul><div class="post-comment"></div></main></div><footer class="footer footer-unloaded"><div class="social"></div></footer></div><div class="toc-wrapper toc-wrapper-loding" style="top:50vh"><div class="toc-catalog"><span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E4%B8%BB%E8%A6%81%E9%92%88%E5%AF%B9C-C-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%A2%B3%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">本文主要针对C&#x2F;C++常用函数库进行梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA"><span class="toc-number">1.1.</span> <span class="toc-text">文章导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%93%E8%AF%A6%E6%83%85"><span class="toc-number">1.2.</span> <span class="toc-text">函数库详情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stdio%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">stdio标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stdio-h%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">stdio.h变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdio-h%E5%AE%8F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">stdio.h宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdio-h%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">stdio.h函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stdlib%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">stdlib标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stdlib-h%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">stdlib.h变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdlib-h%E5%AE%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">stdlib.h宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stdlib-h%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">stdlib.h函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">string标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string-h%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">string.h变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-h%E5%AE%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">string.h宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#string-h%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">string.h函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unistd%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">1.2.4.</span> <span class="toc-text">unistd标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unistd-h%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">unistd.h变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unistd-h%E5%AE%8F"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">unistd.h宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unistd-h%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">unistd.h函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A%E4%BE%BF%E6%98%AF%E6%9C%AC%E7%AB%A0%E8%8A%82%E5%85%A8%E9%83%A8%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.</span> <span class="toc-text">以上便是本章节全部内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%9F%E8%B0%A2%E9%98%85%E8%AF%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">感谢阅读</span></a></li></ol></li></ol></li></ol></div><div class="sidebar sidebar-hide"><ul class="sidebar-tabs sidebar-tabs-active-0"><li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li><li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li><li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li></ul><div class="sidebar-content sidebar-content-show-archive"><div class="sidebar-panel-archives"><div class="total-and-search"><div class="total-archive">Total : 56</div></div><div class="post-archive"><div class="archive-year">2025</div><ul class="year-list"><li class="archive-post-item"><span class="archive-post-date">04/21</span> <a class="archive-post-title" href="/s/redis.html">云原生部署redis服务</a></li><li class="archive-post-item"><span class="archive-post-date">03/27</span> <a class="archive-post-title" href="/s/c-power.html">C语言中的函数库与对应作用</a></li><li class="archive-post-item"><span class="archive-post-date">03/11</span> <a class="archive-post-title" href="/s/version.html">Linux查看内核及系统版本相关技巧</a></li><li class="archive-post-item"><span class="archive-post-date">03/11</span> <a class="archive-post-title" href="/s/view-storage.html">Linux查看存储相关技巧</a></li><li class="archive-post-item"><span class="archive-post-date">03/10</span> <a class="archive-post-title" href="/s/day.html">Linux常用查找/筛选/改写等使用技巧</a></li><li class="archive-post-item"><span class="archive-post-date">03/10</span> <a class="archive-post-title" href="/s/ziprar.html">压缩工具ZIP与RAR使用技巧</a></li><li class="archive-post-item"><span class="archive-post-date">03/10</span> <a class="archive-post-title" href="/s/tar.html">压缩工具TAR的日常使用</a></li><li class="archive-post-item"><span class="archive-post-date">03/07</span> <a class="archive-post-title" href="/s/ranger.html">文件管理器使用RANGER使用指导</a></li><li class="archive-post-item"><span class="archive-post-date">03/07</span> <a class="archive-post-title" href="/s/tmux.html">分屏工具TMUX使用指导</a></li><li class="archive-post-item"><span class="archive-post-date">02/04</span> <a class="archive-post-title" href="/s/vim.html">编辑器VI/VIM操作指导</a></li><li class="archive-post-item"><span class="archive-post-date">02/01</span> <a class="archive-post-title" href="/s/61keyboard.html">机械键盘(61键)通用操作指导</a></li><li class="archive-post-item"><span class="archive-post-date">01/14</span> <a class="archive-post-title" href="/s/fluxbox-lxdm.html">LXDM登陆器与Fluxbox窗口桌面环境</a></li><li class="archive-post-item"><span class="archive-post-date">01/03</span> <a class="archive-post-title" href="/s/3a-cert.html">机构认证【域名+VPS证书】</a></li><li class="archive-post-item"><span class="archive-post-date">01/02</span> <a class="archive-post-title" href="/s/cert.html">生成256P1加密自签证书</a></li></ul><div class="archive-year">2024</div><ul class="year-list"><li class="archive-post-item"><span class="archive-post-date">06/26</span> <a class="archive-post-title" href="/s/pve-lxc-dhcp.html">PVE部署网关/dhcp服务器</a></li><li class="archive-post-item"><span class="archive-post-date">06/26</span> <a class="archive-post-title" href="/s/pve-local-lvm.html">PVE节点local扩容</a></li><li class="archive-post-item"><span class="archive-post-date">06/26</span> <a class="archive-post-title" href="/s/zmap.html">扫描工具ZMap基本用法</a></li><li class="archive-post-item"><span class="archive-post-date">06/24</span> <a class="archive-post-title" href="/s/pyrit.html">Python2编译pyrit</a></li><li class="archive-post-item"><span class="archive-post-date">06/24</span> <a class="archive-post-title" href="/s/redir-socat.html">Redir与Socat重定向转发</a></li><li class="archive-post-item"><span class="archive-post-date">06/23</span> <a class="archive-post-title" href="/s/portoff.html">Linux各端口的关闭</a></li><li class="archive-post-item"><span class="archive-post-date">06/22</span> <a class="archive-post-title" href="/s/owncloud.html">Docker部署OwnCloud</a></li><li class="archive-post-item"><span class="archive-post-date">06/21</span> <a class="archive-post-title" href="/s/win-choco.html">Windows部署Chocolatey</a></li><li class="archive-post-item"><span class="archive-post-date">06/20</span> <a class="archive-post-title" href="/s/ssh-scp.html">传输SCP工具指令</a></li><li class="archive-post-item"><span class="archive-post-date">06/19</span> <a class="archive-post-title" href="/s/webfountion.html">Docker部署typecho框架</a></li><li class="archive-post-item"><span class="archive-post-date">06/19</span> <a class="archive-post-title" href="/s/arch-storage.html">Archlinux物理逻辑分区挂载</a></li><li class="archive-post-item"><span class="archive-post-date">06/18</span> <a class="archive-post-title" href="/s/arch-storage-lvm.html">Archlinux逻辑LVM分区挂载</a></li><li class="archive-post-item"><span class="archive-post-date">06/18</span> <a class="archive-post-title" href="/s/centos-cli-zhcn.html">Centos8系统Cli环境汉化</a></li><li class="archive-post-item"><span class="archive-post-date">06/18</span> <a class="archive-post-title" href="/s/networkd.html">Linux通用网络配置</a></li><li class="archive-post-item"><span class="archive-post-date">06/17</span> <a class="archive-post-title" href="/s/debian-cli-zhcn.html">Debian/Ubuntu系统Cli环境汉化</a></li><li class="archive-post-item"><span class="archive-post-date">06/17</span> <a class="archive-post-title" href="/s/pve-iommu.html">PVE开启硬件直通</a></li><li class="archive-post-item"><span class="archive-post-date">06/15</span> <a class="archive-post-title" href="/s/pve-lxcfull.html">PVE容器LXC多层嵌套</a></li><li class="archive-post-item"><span class="archive-post-date">06/14</span> <a class="archive-post-title" href="/s/addressscan.html">主机地址与归属地查询</a></li><li class="archive-post-item"><span class="archive-post-date">06/12</span> <a class="archive-post-title" href="/s/cointop.html">docker部署Cointop</a></li><li class="archive-post-item"><span class="archive-post-date">06/12</span> <a class="archive-post-title" href="/s/dockerproxy.html">Docker代理配置</a></li><li class="archive-post-item"><span class="archive-post-date">06/12</span> <a class="archive-post-title" href="/s/docker-install.html">Docker安装</a></li><li class="archive-post-item"><span class="archive-post-date">06/08</span> <a class="archive-post-title" href="/s/docker-shell.html">Docker容器内部shell操作</a></li><li class="archive-post-item"><span class="archive-post-date">06/02</span> <a class="archive-post-title" href="/s/ufw.html">UFW防火墙日常操作</a></li><li class="archive-post-item"><span class="archive-post-date">06/01</span> <a class="archive-post-title" href="/s/http-https.html">HTTP三次握手与HTTPS加密通信</a></li><li class="archive-post-item"><span class="archive-post-date">05/31</span> <a class="archive-post-title" href="/s/ping-tracert.html">Ping与Tracert工具</a></li><li class="archive-post-item"><span class="archive-post-date">05/29</span> <a class="archive-post-title" href="/s/osi-tcp.html">OSI与TCP/IP的异同与工作逻辑</a></li><li class="archive-post-item"><span class="archive-post-date">05/29</span> <a class="archive-post-title" href="/s/mysql.html">Tty界面进行MySQL数据库操作</a></li><li class="archive-post-item"><span class="archive-post-date">05/26</span> <a class="archive-post-title" href="/s/nmap-zenmap.html">nmap与zenmap日常使用命令</a></li><li class="archive-post-item"><span class="archive-post-date">05/20</span> <a class="archive-post-title" href="/s/debian-sources.html">Debian/Ubuntu部署本地镜像软件源</a></li><li class="archive-post-item"><span class="archive-post-date">05/14</span> <a class="archive-post-title" href="/s/trojan.html">搭建tls加密线路</a></li><li class="archive-post-item"><span class="archive-post-date">05/02</span> <a class="archive-post-title" href="/s/ip-mask.html">浅谈子网掩码与IP地址的理解</a></li></ul><div class="archive-year">2023</div><ul class="year-list"><li class="archive-post-item"><span class="archive-post-date">12/30</span> <a class="archive-post-title" href="/s/ccat-install.html">ccat二进制源码部署</a></li><li class="archive-post-item"><span class="archive-post-date">05/16</span> <a class="archive-post-title" href="/s/Shell-Customization.html">Linux命令行优化</a></li><li class="archive-post-item"><span class="archive-post-date">05/12</span> <a class="archive-post-title" href="/s/Linux-Novice-Function.html">Linux-新手-基建</a></li><li class="archive-post-item"><span class="archive-post-date">04/15</span> <a class="archive-post-title" href="/s/Linux-Command.html">Linux系统常用命令</a></li><li class="archive-post-item"><span class="archive-post-date">04/07</span> <a class="archive-post-title" href="/s/Armbian-Detail.html">Armbian-细节文章</a></li><li class="archive-post-item"><span class="archive-post-date">04/06</span> <a class="archive-post-title" href="/s/Archlinux-Detail.html">Archlinux-细节文章</a></li><li class="archive-post-item"><span class="archive-post-date">04/04</span> <a class="archive-post-title" href="/s/Gnome.html">Gnome桌面环境优化</a></li><li class="archive-post-item"><span class="archive-post-date">04/04</span> <a class="archive-post-title" href="/s/Kubernetes-1-infrastructure.html">CentOS7离线部署K8s_环境调优</a></li><li class="archive-post-item"><span class="archive-post-date">04/04</span> <a class="archive-post-title" href="/s/Kubernetes-2-installtools.html">CentOS7离线部署K8s_安装工具</a></li><li class="archive-post-item"><span class="archive-post-date">04/04</span> <a class="archive-post-title" href="/s/Kubernetes-3-centerbuild.html">CentOS7离线部署K8s_集群部署</a></li><li class="archive-post-item"><span class="archive-post-date">04/04</span> <a class="archive-post-title" href="/s/Kubernetes-4-plugin.html">CentOS7离线部署K8s_插件管理</a></li></ul></div></div><div class="sidebar-panel-tags"><div class="sidebar-tags-name"></div><div class="iconfont-archer sidebar-tags-empty">&#xe678;</div><div class="tag-load-fail" style="display:none;color:#ccc;font-size:.6rem">缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98</div><div class="sidebar-tags-list"></div></div><div class="sidebar-panel-categories"><div class="sidebar-categories-name"></div><div class="iconfont-archer sidebar-categories-empty">&#xe678;</div><div class="sidebar-categories-list"></div></div></div></div><script>var siteMetaRoot="/";"undefined"===siteMetaRoot&&(siteMetaRoot="/");var siteMeta={url:"https://cyber-mobile.net",root:siteMetaRoot,author:"dot1q@Anonymous"}</script><script src="/scripts/main.js?v=20211217"></script><script src="/scripts/dark.js?v=20211217"></script><script src="/static/jquery.fancybox.min.js" defer></script><script src="/static/busuanzi.pure.mini.js" async></script><script src="/scripts/share.js?v=20211217" async></script></body></html>